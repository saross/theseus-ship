{
  "uuid": "7550e11b-4a12-4830-8cd4-dc595fc4c2c4",
  "name": "Verify Semantic Scholar API Key",
  "summary": "",
  "created_at": "2025-02-13T03:56:01.752968Z",
  "updated_at": "2025-02-13T03:56:11.532664Z",
  "account": {
    "uuid": "17538ba7-7aa5-450c-9d3f-69ab346ad799"
  },
  "chat_messages": [
    {
      "uuid": "89eafb5d-ac3d-4aa3-9a29-409ae028682a",
      "text": "Can you take these docs and give me a basic curl command to see if my api key works, please? $SEMANTIC_SCHOLAR_API_KEY is the variable",
      "content": [
        {
          "start_timestamp": "2025-02-13T03:15:46.884869Z",
          "stop_timestamp": "2025-02-13T03:15:46.884869Z",
          "flags": null,
          "type": "text",
          "text": "Can you take these docs and give me a basic curl command to see if my api key works, please? $SEMANTIC_SCHOLAR_API_KEY is the variable",
          "citations": []
        }
      ],
      "sender": "human",
      "created_at": "2025-02-13T03:56:02.716755Z",
      "updated_at": "2025-02-13T03:56:02.716755Z",
      "attachments": [
        {
          "file_name": "paste.txt",
          "file_size": 49592,
          "file_type": "txt",
          "extracted_content": "Semantic Scholar\nSearch over 214 million papers from all fields of science\n\nLogo for Semantic Scholar Academic Graph API\nSemantic Scholar API\nOverview\nTutorial\nDocumentation\nGallery\nCite the Paper\nSemantic Scholar API - Tutorial\nGet Started with Semantic Scholar API\n\nLearn to search for papers and authors, download datasets, and more\n\nQuick guide to get started with Semantic Scholar API\nIntroduction\nWhat is an API?\nThe Semantic Scholar APIs\nHow to make requests faster and more efficiently\nExample: Request paper details\nMake Calls to the Semantic Scholar API\nStep 1: Keyword search for relevant papers\nStep 2: Get recommended papers\nStep 3: Look up authors\nAdditional Resources\nPagination\nExamples using search query parameters\nHow to download full datasets\nHow to update datasets with incremental diffs\nTips for working with downloaded datasets\nIntroduction\nThe Semantic Scholar REST API uses standard HTTP verbs, response codes, and authentication. This tutorial will teach you how to interact with the API by sending requests and analyzing the responses. All code examples are shown in Python. If you prefer a code-free experience, follow along using the Semantic Scholar Postman Collection, which lets you test out the API on Postman, a popular and free API testing platform.\n\nWhat is an Application Programming Interface (API)?\nAn API is a structured way for applications to communicate with each other. Applications can send API requests to one another, for instance to retrieve data.\n\nEach API request consists of:\n\nAn API endpoint, which is the URL that requests are sent to. The URL consists of the API\u2019s base URL and the specific endpoint\u2019s resource path (See Figure 1).\nA request method, such as GET or POST. This is sent in the HTTP request and tells the API what type of action to perform.\na diagram displaying the base url [https://api.semanticscholar.org/graph/v1/] and resource path [/paper/search]\nFigure 1. The endpoint for Semantic Scholar\u2019s paper relevance search endpoint.\n\nEach API request may also include:\n\nQuery parameters, which are appended to the end of the URL, after the resource path.\nA request header, which may contain information about the API key being used.\nA request body, which contains data being sent to the API.\nAfter the request is sent, the API will return a response. The response includes a status code indicating whether the request was successful and any requested data. The response may also include requested data.\n\nCommon status codes are:\n\n200, OK. The request was successful.\n400, Bad Request. The server could not understand your request. Check your parameters.\n401, Unauthorized. You're not authenticated or your credentials are invalid.\n403, Forbidden. The server understood the request but refused it. You don't have permission to access the requested resource.\n404, Not Found. The requested resource or endpoint does not exist.\n429, Too Many Requests. You've hit the rate limit, slow down your requests.\n500, Internal Server Error. Something went wrong on the server\u2019s side.\nThe Semantic Scholar APIs\nSemantic Scholar contains three APIs, each with its own unique base URL:\n\nAcademic Graph API returns details about papers, paper authors, paper citations and references. Base URL: https://api.semanticscholar.org/graph/v1\nRecommendations API recommends papers based on other papers you give it. Base URL: https://api.semanticscholar.org/recommendations/v1\nDatasets API lets you download Semantic Scholar\u2019s datasets onto your local machine, so you can host the data yourself and do custom queries. Base URL: https://api.semanticscholar.org/datasets/v1\nSee the Semantic Scholar API documentation for more information about each API and their endpoints. The documentation describes how to correctly format requests and parse responses for each endpoint.\n\nHow to make requests faster and more efficiently\nHeavy use of the API can cause a slowdown for everyone. Here are some tips to avoid hitting rate limit ceilings and slowdowns when making requests:\n\nUse an API Key. Users without API keys are affected by the traffic from all other unauthenticated users, who share a single API key. But using an individual API key automatically gives a user a 1 request per second rate across all endpoints. In some cases, users may be granted a slightly higher rate following a review. Learn more about API keys and how to request one here.\nUse batch endpoints. Some endpoints have a corresponding batch or bulk endpoint that returns more results in a single response. Examples include the paper relevance search (bulk version: paper bulk search) and the paper details endpoint (batch version: paper batch endpoint). When requesting large quantities of data, use the bulk or batch versions whenever possible.\nLimit \u201cfields\u201d parameters. Most endpoints in the API contain the \u201cfields\u201d query parameter, which allows users to specify what data they want returned in the response. Avoid including more fields than you need, because that can slow down the response rate.\nDownload Semantic Scholar Datasets. When you need a request rate that is higher than the rate provided by API keys, you can download Semantic Scholar\u2019s datasets and run queries locally. The Datasets API provides endpoints for easily downloading and maintaining Semantic Scholar datasets. See the How to Download Full Datasets section of the tutorial under Additional Resources for more details.\nExample: Request paper details (using Python)\nNow we\u2019ll make a request to the paper details endpoint by running Python code. Complete the steps listed under Prerequisites below before proceeding. If you prefer to follow along in Postman, the same request in Postman is located here. For more examples of API requests using Python, see the section Make Calls to the Semantic Scholar API.\n\nPrerequisites:\n\nInstall Python if it is not already on your machine.\nInstall pip, Python's package manager, if it is not already on your machine.\nAccording to the Academic Graph API documentation, the paper details endpoint is a GET method and its resource path is /paper/{paper_id}.\n\na diagram displaying the base url [https://api.semanticscholar.org/graph/v1/] and resource path [/paper/search]\nFigure 2. Each endpoint's resource path is listed in the API documentation.\n\nWhen combined with the Academic Graph base URL, the endpoint\u2019s URL is: https://api.semanticscholar.org/graph/v1/paper/{paper_id}\n\nThe curly brackets in the resource path indicate that paper_id is a path parameter, which is replaced by a value when the request is sent. Accepted formats for the value of paper_id are detailed in the Path Parameters section of the documentation.\n\na diagram displaying the base url [https://api.semanticscholar.org/graph/v1/] and resource path [/paper/search]\nFigure 3. Accepted formats are listed in the Path Parameters section.\n\nThe Query Parameters section of the documentation only lists a single optional parameter: fields. The fields parameter takes a string of comma-separated field names, which tell the API what information to return in the response.\n\na diagram displaying the base url [https://api.semanticscholar.org/graph/v1/] and resource path [/paper/search]\nFigure 4. Fields that can be returned in the response are listed in the Response Schema section of Responses.\n\nFor our Python request, we'll query the same paper ID given in the documentation\u2019s example. We'll request the paper\u2019s title, the year of publication, the abstract, and the citationCount fields:\n\nimport requests\n\npaperId = \"649def34f8be52c8b66281af98ae884c09aef38b\"\n\n# Define the API endpoint URL\nurl = f\"http://api.semanticscholar.org/graph/v1/paper/{paperId}\"\n\n# Define the query parameters\nquery_params = {\"fields\": \"title,year,abstract,citationCount\"}\n\n# Directly define the API key (Reminder: Securely handle API keys in production environments)\napi_key = \"your api key goes here\"  # Replace with the actual API key\n\n# Define headers with API key\nheaders = {\"x-api-key\": api_key}\n\n# Send the API request\nresponse = requests.get(url, params=query_params, headers=headers)\n\n# Check response status\nif response.status_code == 200:\n   response_data = response.json()\n   # Process and print the response data as needed\n   print(response_data)\nelse:\n   print(f\"Request failed with status code {response.status_code}: {response.text}\")\n\nNote that this request is using an API key. The use of API keys is optional but recommended. Learn more about API keys and how to get one here.\n\nWe are using the Python Requests library to send the request. So we know the response has a property named status_code that returns the response status. We check the status_code and either print the successfully returned data or the error message.\n\nSee the API documentation for how the response is formatted. Each Status Code section expands with further details about the response data that is returned.\n\na diagram displaying the base url [https://api.semanticscholar.org/graph/v1/] and resource path [/paper/search]\nFigure 5. The Responses section describes how responses are formatted.\n\nWhen the request is successful, the JSON object returned in the response is:\n\n{\n    \"paperId\": \"649def34f8be52c8b66281af98ae884c09aef38b\",\n    \"title\": \"Construction of the Literature Graph in Semantic Scholar\",\n    \"abstract\": \"We describe a deployed scalable system for organizing published ...\",\n    \"year\": 2018,\n    \"citationCount\": 365\n}\n\nSee the Make Calls to the Semantic Scholar API section for more Python examples using the paper search, paper recommendations, and authors endpoints.\n\nMake Calls to the Semantic Scholar API\nUse Case: Let's suppose you are an early-career academic researcher interested in doing research in generative AI. You would like to learn about recent research developments in the generative AI field and discover what areas are most exciting for future research.\n\nHow to use Semantic Scholar: You can do a keyword search for relevant papers on generative AI. You can pick out a few papers that seem the most interesting, then recommend more papers that are similar to them. You can examine the list of recommended papers to see which are the most cited and which authors worked on them, then look up other research by those same authors.\n\nLet\u2019s walk through those scenarios together. We\u2019re going to use Python, but you can follow along using the Postman collection.\n\nStep 1: Keyword search for relevant papers\nUse Case: We want to learn more about generative AI, so we\u2019ll start by searching for recent generative AI research papers.\n\nTwo Academic Graph API endpoints use Semantic Scholar\u2019s custom-trained ranker to perform keyword searches: the paper relevance search endpoint and the paper bulk search endpoint.\n\nPaper bulk search should be used in most cases because paper relevance search is more resource intensive. The paper relevance search endpoint is able to return more detailed information about each paper\u2019s authors, its referenced papers, and the papers that cite it. The paper bulk search supports sorting and special syntax in the query parameter. In this scenario, we will use the paper bulk search endpoint.\n\nGet the Endpoint URL\nThe Academic Graph API endpoint\u2019s base URL is: http://api.semanticscholar.org/graph/v1/\n\nWhenever we want to retrieve data from or send data to an endpoint in the Academic Graph, that\u2019s how the URL starts. The API documentation for paper bulk search endpoint lists its resource path as /paper/search/bulk, so the endpoint\u2019s full URL is:\n\nhttp://api.semanticscholar.org/graph/v1/paper/search/bulk\nSet the Query Parameters\nThe paper bulk search API documentation lists the following query parameters:\n\nquery sets the search term\ntoken automatically handles pagination\nfields determines what data the API endpoint will return to you\nsort allows users to sort the results by the paperId, publicationDate, or citationCount fields\npublicationTypes filters results by paper publication type (e.g. journal articles)\nopenAccessPdf filters results by whether they contain public PDFs of papers\nminCitationCount filters results by whether they have at least a given number of citations\npublicationDateOrYear filters results by a date range\nyear filters results by a year range\nvenue filters results by publication venue\nfieldsOfStudy filters results by the paper\u2019s field of study\nOnly the first query parameter, query, is required in every request. The token query parameter isn\u2019t included in the original request. Instead, it is returned in the response to the original request, then included in subsequent requests to automatically handle pagination.\n\nIn our request, we will include 3 query parameters: query, fields, and year:\n\nUse quotation marks in the query to search for the phrase \u201cgenerative AI\u201d. See the Additional Help section for more examples of using search query syntax.\nIn fields, include the title, url, type of publication, date of publication, and link to the pdf of the paper. Separate field names with commas, without spaces. See the API documentation for all available field names.\nFilter for papers published during or after the year 2023 by using the \u201c2023\u2013\u201d syntax.\nThese query parameters are appended to the end of the URL, so the complete URL looks like this: http://api.semanticscholar.org/graph/v1/paper/search/bulk?query=\"generative ai\"&fields=title,url,publicationTypes,publicationDate,openAccessPdf&year=2023-\n\nSend the Request\nThe URL is long and hard to read, so in our code we\u2019ll break it up a bit:\n\nimport requests\nimport json\n\n# Specify the search term\nquery = '\"generative ai\"'\n\n# Define the API endpoint URL\nurl = \"http://api.semanticscholar.org/graph/v1/paper/search/bulk\"\n\n# Define the query parameters\nquery_params = {\n    \"query\": '\"generative ai\"',\n    \"fields\": \"title,url,publicationTypes,publicationDate,openAccessPdf\",\n    \"year\": \"2023-\"\n}\n\n# Directly define the API key (Reminder: Securely handle API keys in production environments)\napi_key = \"your api key goes here\"  # Replace with the actual API key\n\n# Define headers with API key\nheaders = {\"x-api-key\": api_key}\n\n# Send the API request\nresponse = requests.get(url, params=query_params, headers=headers).json()\nThe request is formatted and sent to the API endpoint, and the response is captured in the variable response.\n\nAccording to the API documentation, if the request was successful, with status code 200, the response variable contains three fields:\n\nPostman Request\nFigure 6. The API documentation lists the data format of the response schema.\n\nThe total parameter is an estimate of how many papers were found that matched the search request, the token parameter is used for pagination, and the data parameter contains the data returned from the endpoint. Note that the paper bulk search endpoint\u2019s use of tokens to handle pagination is unlike the paper relevance search endpoint\u2019s use of the offset and limit query parameters for pagination.\n\nThe next part of our code saves the data returned from the endpoint to a json file titled papers.json and prints the code\u2019s progress to the console. If the token parameter is present, fetch the next batch of responses.\n\nprint(f\"Will retrieve an estimated {response['total']} documents\")\nretrieved = 0\n\n# Write results to json file and get next batch of results\nwith open(f\"papers.json\", \"a\") as file:\n    while True:\n        if \"data\" in response:\n            retrieved += len(response[\"data\"])\n            print(f\"Retrieved {retrieved} papers...\")\n            for paper in response[\"data\"]:\n                print(json.dumps(paper), file=file)\n        # checks for continuation token to get next batch of results\n        if \"token\" not in response:\n            break\n        response = requests.get(f\"{url}&token={response['token']}\").json()\n\nprint(f\"Done! Retrieved {retrieved} papers total\")\nEach data object in the papers.json file contains the fields we requested, as well as the paperId.\n\n{\n    \"paperId\": \"001720a782840652b573bb4794774aee826510ca\",\n    \"url\": \"https://www.semanticscholar.org/paper/001720a782840652b573bb4794774aee826510ca\",\n    \"title\": \"Developing Design Features to Facilitate AI-Assisted User Interactions\",\n    \"openAccessPdf\": null,\n    \"publicationTypes\": null,\n    \"publicationDate\": \"2024-05-03\"\n}\n{\n    \"paperId\": \"0019e876188f781fdca0c0ed3bca39d0c70c2ad2\",\n    \"url\": \"https://www.semanticscholar.org/paper/0019e876188f781fdca0c0ed3bca39d0c70c2ad2\",\n    \"title\": \"Artificial intelligence prompt engineering as a new digital competence: Analysis of generative AI technologies such as ChatGPT\",\n    \"openAccessPdf\": {\n        \"url\": \"https://eber.uek.krakow.pl/index.php/eber/article/view/2142/863\",\n        \"status\": \"GOLD\"\n    },\n    \"publicationTypes\": [\n        \"JournalArticle\",\n        \"Review\"\n    ],\n    \"publicationDate\": null\n}\nSee the S2folks GitHub code examples for another version of this call.\n\nStep 2: Get recommended papers\nUse Case: In this section, we want to get a list of recommended papers based on a few interesting seed papers. We\u2019re interested in the most cited papers, so we\u2019ll request information about the recommended papers\u2019 citation counts.\n\nTwo Recommendations API endpoints can recommend papers: one gives recommendations based on a single seed paper from the user, while the other takes a list of positive seed papers and a list of negative seed papers from the user. Both endpoints return an array of papers in descending order of relevance.\n\nWe will use the endpoint that takes two lists of positive and negative seed papers, with the URL: http://api.semanticscholar.org/recommendations/v1/papers\n\nThis is a POST request, so we need to check the endpoint\u2019s Request Body Schema section in the API documentation, to see the format in which the data must be sent in the body of the request.\n\n\nFigure 7. The Request Body Schema section describes how to format the data in a POST request.\n\nThe positive and negative seed paperIds need to be sent as two arrays, positivePaperIds and negativePaperIds.\n\nFor positivePaperIds, we\u2019ll use two positive seed papers:\n\nHuman-Centred AI in Education in the Age of Generative AI Tools, paperId 02138d6d094d1e7511c157f0b1a3dd4e5b20ebee\nResponsible Adoption of Generative AI in Higher Education: Developing a \"Points to Consider\u201d Approach Based on Faculty Perspectives, paperId 018f58247a20ec6b3256fd3119f57980a6f37748\nFor negativePaperIds, we\u2019ll use one negative seed paper:\n\nA Novel Generative AI-Based Framework for Anomaly Detection in Multicast Messages in Smart Grid Communications, paperId 0045ad0c1e14a4d1f4b011c92eb36b8df63d65bc\nIn our request to this API endpoint, we provide the following query parameters:\n\nThe fields query parameter, with the citationCount field, which returns how much that particular paper is cited by other papers. We won\u2019t include the influentialCitationCount field here, but that field keeps track of how often the paper has a big influence on other papers.\nThe limit query parameter, which limits the number of recommended papers returned. We\u2019ll set this to the max value of 500.\nIn a new Python script, the request is formatted and sent to the API endpoint.\n\nimport requests\nimport json\n\n# Define the API endpoint URL\nurl = \"https://api.semanticscholar.org/recommendations/v1/papers\"\n\n# Define the query parameters\nquery_params = {\n    \"fields\": \"title,url,citationCount,authors\",\n    \"limit\": \"500\"\n}\n\n# Define the request data\ndata = {\n    \"positivePaperIds\": [\n        \"02138d6d094d1e7511c157f0b1a3dd4e5b20ebee\", \n        \"018f58247a20ec6b3256fd3119f57980a6f37748\"\n    ],\n    \"negativePaperIds\": [\n        \"0045ad0c1e14a4d1f4b011c92eb36b8df63d65bc\"\n    ]\n}\n\n# Directly define the API key (Reminder: Securely handle API keys in production environments)\napi_key = \"your api key goes here\"  # Replace with the actual API key\n\n# Define headers with API key\nheaders = {\"x-api-key\": api_key}\n\n# Send the API request\nresponse = requests.post(url, params=query_params, json=data, headers=headers).json()\n\n# Sort the recommended papers by citation count\npapers = response[\"recommendedPapers\"]\npapers.sort(key=lambda paper: paper[\"citationCount\"], reverse=True)\n\nwith open('recommended_papers_sorted.json', 'w') as output:\n    json.dump(papers, output)\nA successful request returns a response with the recommendedPapers parameter. Since we want to see the most cited papers, the papers are sorted by the citationCount parameter, then the results are written to a JSON file, recommended_papers_sorted.json:\n\n[\n    {\n        \"paperId\": \"833ff07d2d1be9be7b12e88487d5631c141a2e95\",\n        \"url\": \"https://www.semanticscholar.org/paper/833ff07d2d1be9be7b12e88487d5631c141a2e95\",\n        \"title\": \"Teacher Professional Development on Self-Determination Theory\\u2013Based Design Thinking in STEM Education\",\n        \"citationCount\": 24,\n        \"authors\": [\n            {\n                \"authorId\": \"2281351310\",\n                \"name\": \"Thomas K. F. Chiu\"\n            },\n            {\n                \"authorId\": \"2281342663\",\n                \"name\": \"C. Chai\"\n            },\n            {\n                \"authorId\": \"2300302076\",\n                \"name\": \"P. J. Williams\"\n            },\n            {\n                \"authorId\": \"2300141520\",\n                \"name\": \"Tzung-Jin Lin\"\n            }\n        ]\n    },\n    {\n        \"paperId\": \"144b8d9c10ea111598aa239100cd6ed5c6137b1c\",\n        \"url\": \"https://www.semanticscholar.org/paper/144b8d9c10ea111598aa239100cd6ed5c6137b1c\",\n        \"title\": \"Artificial intelligence as part of future practices in the architect\\u2019s work: MidJourney generative tool as part of a process of creating an architectural form\",\n        \"citationCount\": 19,\n        \"authors\": [\n            {\n                \"authorId\": \"2300748516\",\n                \"name\": \"Anna Jaruga-Rozdolska\"\n            }\n        ]\n    },\nThe recommended papers are now sorted in descending order of citation count, with a paper with 24 citations at the top of the list.\n\nSee the S2folks GitHub for an example of using the recommendations endpoint that takes a single seed paper.\n\nStep 3: Look up authors\nUse Case: We want to get more information about the authors of the highest cited paper.\n\nThe batch authors endpoint in Academic Graph API can return information about multiple authors: https://api.semanticscholar.org/graph/v1/author/batch.\n\nThis endpoint is a POST, and it accepts an array of authorIds called ids in the request body. The array includes authorIds of the four authors of the most cited paper:\n\n2281351310\n2281342663\n2300302076\n2300141520\nThe only query parameter accepted by the endpoint is fields, where we can request more detailed information about the authors, including:\n\nThe author name\nThe url of the author\u2019s page on Semantic Scholar\nTheir number of papers in Semantic Scholar, called paperCount\nThe author\u2019s hIndex, a measure of their research impact\nAn array of all papers by the author in Semantic Scholar\nIn a new Python script, the request is sent to the API endpoint.\n\nimport requests\nimport json\n\n# Define the API endpoint URL\nurl = \"https://api.semanticscholar.org/graph/v1/author/batch\"\n\n# Define the query parameters\nquery_params = {\n    \"fields\": \"name,url,paperCount,hIndex,papers\"\n}\n\n# Define the request data\ndata = {\n    \"ids\": [\"2281351310\",\"2281342663\",\"2300302076\",\"2300141520\"]\n}\n\n# Directly define the API key (Reminder: Securely handle API keys in production environments)\napi_key = \"your api key goes here\"  # Replace with the actual API key\n\n# Define headers with API key\nheaders = {\"x-api-key\": api_key}\n\n# Send the API request\nresponse = requests.post(url, params=query_params, json=data, headers=headers).json()\n\n# Save the results to json file\nwith open('author_information.json', 'w') as output:\n    json.dump(response, output)\nThe successful request returns an array of objects that contain author information.\n\n[\n    {\n        \"authorId\": \"2281351310\",\n        \"url\": \"https://www.semanticscholar.org/author/2281351310\",\n        \"name\": \"Thomas K. F. Chiu\",\n        \"paperCount\": 2,\n        \"hIndex\": 1,\n        \"papers\": [\n            {\n                \"paperId\": \"630642b7040a0c396967e4dab93cf73094fa4f8f\",\n                \"title\": \"An experiential learning approach to learn AI in an online workshop\"\n            },\n            {\n                \"paperId\": \"833ff07d2d1be9be7b12e88487d5631c141a2e95\",\n                \"title\": \"Teacher Professional Development on Self-Determination Theory\\u2013Based Design Thinking in STEM Education\"\n            }\n        ]\n    },\nSee the S2folks GitHub for other interesting examples of using the author endpoints.\n\nAdditional Resources\nPagination\nPagination is a technique used in APIs to manage and retrieve large sets of data in smaller, manageable chunks. This is particularly useful when dealing with extensive datasets to improve efficiency and reduce the load on both the client and server.\n\nSome Semantic Scholar endpoints, like paper relevance search, require the use of the limit and offset parameters to handle pagination:\n\nLimit: Specifies the maximum number of items (e.g., papers) to be returned in a single API response. For example, in the request https://api.semanticscholar.org/graph/v1/paper/search?query=halloween&limit=3, the limit=3 indicates that the response should include a maximum of 3 papers.\nOffset: Represents the starting point from which the API should begin fetching items. It helps skip a certain number of items. For example, if offset=10, the API will start retrieving items from the 11th item onward.\nOther endpoints, like paper bulk search, require the use of the token parameter to handle pagination:\n\nToken: A \u201cnext\u201d token or identifier provided in the response, pointing to the next set of items. It allows fetching the next page of results.\nIn either case, the client requests the API for the first page of results. The API responds with a limited number of items. If there are more items to retrieve, the client can use the offset parameter or the next token in subsequent requests to get the next page of results until all items are fetched. This way, pagination allows clients to retrieve large datasets efficiently, page by page, based on their needs.\n\nExamples using search query parameters\nSemantic Scholar\u2019s paper bulk search supports a variety of operators that enable advanced filtering and precise specifications in search queries. All keywords in the search query are matched against words in the paper\u2019s title and abstract. Refer to the API Documentation for all supported operators. Below are examples of varying complexity to help you get started.\n\nExample 1.\n\n((cloud computing) | virtualization) +security -privacy\nMatches papers containing the words \"cloud\u201d and \u201ccomputing\", OR the word \"virtualization\" in their title or abstract. The paper title or abstract must also include the term \"security\" but should exclude the word \"privacy\". For example, a paper with the title \"Ensuring Security in Cloud Computing Environments\" could be included, unless its abstract contains the word \u201cprivacy\u201d.\n\nExample 2.\n\n\"red blood cell\" + artificial intelligence\nMatches papers where the title or abstract contains the exact phrase \u201cred blood cell\u201d along with the words \u201cartificial\u201d and \u201cintelligence\u201d. For example, a paper with the title \"Applications of Artificial Intelligence in Healthcare\" would be included if it also contained the phrase \u201cred blood cell\u201d in its abstract.\n\nExample 3.\n\nfish*\nMatches papers where the title or abstract contains words with \u201cfish\u201d in their prefix, such as \u201cfishtank\u201d, \u201cfishes\u201d, or \u201cfishy\u201d. For example a paper with the title \"Ecology of Deep-Sea Fishes\" would be included.\n\nExample 4.\n\nbugs~3\nMatches papers where the title or abstract contains words with an edit distance of 3 from the word \u201cbugs\u201d, such as \u201cbuggy\u201d, \u201cbut\u201d, \"buns\", \u201cbusg\u201d, etc. An edit is the addition, removal, or change of a single character.\n\nExample 5.\n\n\u201cblue lake\u201d ~3\nMatches papers where the title or abstract contains phrases with up to 3 terms between the words specified in the phrase. For example, a paper titled \u201cPreserving blue lakes during the winter\u201d or with an abstract containing a phrase such as \u201cblue fishes in the lake\u201d would be included.\n\nHow to download full datasets\nSemantic Scholar datasets contain data on papers, authors, abstracts, embeddings, and more. Datasets are grouped by releases, and each release is a snapshot of the datasets at the time of that release date. Make requests to the Datasets API to see the list of available release dates, to list the datasets contained in a given release, and to download links to datasets.\n\nAll Semantic Scholar datasets are delivered in JSON format.\n\nStep 1: See all release dates\nUse the list of available releases endpoint to see all dataset release dates.\n\nimport requests\n\n# Define base URL for datasets API\nbase_url = \"https://api.semanticscholar.org/datasets/v1/release/\"\n\n# To get the list of available releases make a request to the base url. No additional parameters needed.\nresponse = requests.get(base_url)\n\n# Print the response data\nprint(response.json())\n\nThe response is a list of release dates, which contain all releases through the date the request was made:\n\n\nStep 2: See all datasets for a given release date\nUse the list of datasets in a release endpoint to see all datasets contained in a given release. The endpoint takes the release_id, which is simply the release date, as a query parameter. The release_id can also be set to \u201clatest\u201d instead of the actual date value to retrieve datasets from the latest release.\n\nimport requests\n\nbase_url = \"https://api.semanticscholar.org/datasets/v1/release/\"\n\n# Set the release id\nrelease_id = \"2023-10-31\"\n\n# Make a request to get datasets available the latest release\nresponse = requests.get(base_url + release_id)\n\n# Print the response data\nprint(response.json())\n\nStep 3: Get download links for datasets\nUse the download links for a dataset endpoint to get download links for a specific dataset at a specific release date. This step requires the use of a Semantic Scholar API key.\n\nimport requests\n\nbase_url = \"https://api.semanticscholar.org/datasets/v1/release/\"\n\n# This endpoint requires authentication via api key\napi_key = \"your api key goes here\"\nheaders = {\"x-api-key\": api_key}\n\n# Set the release id\nrelease_id = \"2023-10-31\"\n\n# Define dataset name you want to download\ndataset_name = 'papers'\n\n# Send the GET request and store the response in a variable\nresponse = requests.get(base_url + release_id + '/dataset/' + dataset_name, headers=headers)\n\n# Process and print the response data\nprint(response.json())\n\nThe response contains the dataset name, description, a README with license and usage information, and temporary, pre-signed download links for the dataset files:\n\n\nHow to update datasets with incremental diffs\nThe incremental diffs endpoint in the Datasets API allows users to get a comprehensive list of changes\u2014or \u201cdiffs\u201d\u2014between any two releases. Full datasets can be updated from one release to another to avoid downloading and processing data that hasn't changed. This endpoint requires the use of a Semantic Scholar API key.\n\nThis endpoint returns a list of all the \"diffs\" required to catch a given dataset up from the start release date to the end release date, with each \u201cdiff\u201d object containing only the changes from one release to the next sequential release.\n\nEach \"diff\" object itself contains two lists of files: an \"update files\" list and a \"delete files\" list. Records in the \"update files\" list need to be inserted or replaced by their primary key. Records in the \"delete files\" list should be removed from your dataset.\n\nimport requests\n\n# Set the path parameters\nstart_release_id = \"2023-10-31\"\nend_release_id = \"2023-11-14\"\ndataset_name = \"authors\"\n\n# Set the API key. For best practice, store and retrieve API keys via environment variables\napi_key = \"your api key goes here\"\nheaders = {\"x-api-key\": api_key}\n\n# Construct the complete endpoint URL with the path parameters\nurl = f\"https://api.semanticscholar.org/datasets/v1/diffs/{start_release_id}/to/{end_release_id}/{dataset_name}\"\n\n# Make the API request\nresponse = requests.get(url, headers=headers)\n\n\n# Extract the diffs from the response\ndiffs = response.json()['diffs']\nprint(diffs)\n\nTips for working with downloaded datasets\nExplore the following sections for inspiration on leveraging your downloaded data. Please be aware that the tools, libraries, and frameworks mentioned below are not a comprehensive list and their performance will vary based on the size of your data and machine\u2019s capabilities. They are all external tools with no affiliation to Semantic Scholar, and are simply offered as suggestions to facilitate your initial exploration of our data.\n\nCommand line tools\nPerhaps the simplest way to view your downloaded data is via the command line through commands like more and tools like jq.\n\n1. The more command\n\nYou can use the more command without installing any external tool or library. This command is used to display the contents of a file in a paginated manner and lets you page through the contents of your downloaded file in chunks without loading up the entire dataset. It shows one screen of text at a time and allows you to navigate through the file using the spacebar (move forward one screen) and Enter (move forward one line) commands.\n\nExample: You downloaded the papers dataset, and renamed the file to \u201cpapersDataset\u201d. Use the \u201cmore papersDataset\u201d command to view the file:\n\nmore papersDataset output\n2. The jq tool\n\njq is a lightweight and flexible command-line tool for exploring and manipulating JSON data. With jq, you can easily view formatted json output, select and view specific fields, filter data based on conditions, and more.\n\nExample: You downloaded the papers dataset, and renamed the file to \u201cpapersDataset\u201d. The jq command to format output is jq \u2018.\u2019 <file-name>, so use the  jq . papersDataset command to view the formatted file:\n\njq . papersDataset output\nExample: You want to filter publication venues that are only journals. You can use jq to filter json objects by a condition with the command jq \u2018 . | select(has(\u201ctype\u201d) and .type == \u201cjournal\u201d)\u2019 publicationVenues\n\njq Output\nPython Pandas library\nPandas is a powerful and easy-to-use data analysis and manipulation library available in Python. Using Pandas, you can effortlessly import, clean, and explore your data. One of the key structures in Pandas is a DataFrame, which can be thought of as a table of information, akin to a spreadsheet with rows and columns. Each column has a name, similar to a header in Excel, and each row represents a set of related data. With a DataFrame, tasks like sorting, filtering, and analyzing your data are straightforward. Now we will see how to leverage basic Pandas functions to view and explore our Semantic Scholar data in a DataFrame.\n\nExample: The head function. In Pandas you can use the head( ) function to view the initial few rows of your dataframe.\n\nimport pandas as pd\n\n# Read JSON file into Pandas DataFrame. The \u2018lines\u2019 parameter indicates that our file contains one json object per line\ndf = pd.read_json('publication venues dataset', lines=True)\n\n# Print the first few rows of the DataFrame\nprint(df.head())\nThe output is below. You will notice that this is a very wide dataframe, where each column represents a field in our json object (e.g. id, name, issn, url, etc.). By default pandas only shows the first and last columns. To view all the columns, you can configure the pandas display settings before printing your output, with pd.set_option('display.max_columns', None)\n\nPandas head output\nExample: The count function. We can use the count( ) function to count the number of rows that have data in them (e.g. not null). This can be useful to test the quality of your dataset.\n\n# Display count of non-null values for each column\nprint(df.count())\nOutput:\n\nPandas count output\nExample: Filtering. We can filter our data by specifying conditions. For example, let\u2019s assume we have loaded our authors' dataset into a dataframe, and want to filter by authors who have written at least 5 papers and been cited at least 10 times. After applying this filter, let's select and display only the authorid, name, papercount, and citationcount fields.\n\n#filter dataframe by authors who have more than 5 publications and have been cited at least 10 times\ndf = df[(df.papercount >= 5) & (df.citationcount >= 10)]\n\n# Select and print a subset of the columns in our filtered dataframe\nprint(df[['authorid', 'name', 'papercount', 'citationcount']])\nOutput:\n\nPython Pandas Filtering Output\nExample: Sorting. Pandas offers a variety of sorting functions to organize our data. In the example below, we use the sort_values( ) function to sort the dataframe by the \u201cname\u201d column and only display the authorid and name columns. The default is ascending order, so in this case our output will list authors in alphabetical order.   e can filter our data by specifying conditions. For example, let\u2019s assume we have loaded our authors' dataset into a dataframe, and want to filter by authors who have written at least 5 papers and been cited at least 10 times. After applying this filter, let's select and display only the authorid, name, papercount, and citationcount fields.\n\n#Let's sort our authors in alphabetical order\ndf = df.sort_values(by='name')\nOutput:\n\nPython Pandas Sorting Output\nExample: Check for missing values. Let\u2019s say we want to assess the quality of our data by checking for missing (null) values. We can count how many missing values we have by using the isnull() and sum() functions.\n\n# Count and print the number of missing values for each author attribute\nprint(df.isnull().sum())\nOutput:\n\nPython Pandas Checking for missing values Output\nApache Spark (Python examples)\nApache Spark is a fast and powerful processing engine that can analyze large-scale data faster than traditional methods via in-memory caching and optimized query execution. Spark offers APIs for a variety of programming languages, so you can utilize its capabilities regardless of the language you are coding in. In our examples we will showcase the Spark Python API, commonly known as PySpark.\n\nExample: The show function. PySpark\u2019s show( ) function is similar to print( ) or head( ) in pandas and will display the first few rows of data. Let\u2019s load up our publication venues data into a PySpark DataFrame and see how it looks:\n\nfrom pyspark.sql import SparkSession\n\n# Create a Spark session\nspark = SparkSession.builder.appName(\"dataset_exploration\").getOrCreate()\n\n# Read the dataset file named 'publication venues dataset' into a PySpark DataFrame. Depending on the directory you are working from you may need to include the complete file path.\ndf = spark.read.json(\"publication venues dataset\")\n\n# Display the first few rows\ndf.show()\nOutput:\n\nApache Spark Show output\nExample: The printSchema function. PySpark offers a handy printSchema( ) function if you want to explore the structure of your data\n\n# Display the object schema\n\ndf.printSchema()\nOutput:\n\nApache Spark print schema output\nExample: Summary statistics. PySpark offers a handy describe( ) function to delve into and display summary statistics for the specified columns in our dataset. In this example we describe the papercount, citationcount, and orderBy attributes of our author data. In the results we can see the average papercount of authors in this dataset, along with their average citationcount, hindex, and other common statistical measures.\n\ndf.describe([\"papercount\", \"citationcount\", \"hindex\"]).show()\nOutput:\n\nApache Spark Summary Statistics Output\nExample: Sorting. We can call the orderBy( ) function and specify the column we want to sort by, in this case papercount. We also call the desc() function to sort in descending order (from highest to lowest papercount). We also only want to display the authorid, name, and papercount fields, and display the top 3 records.\n\ndf = df.orderBy(col(\"papercount\").desc())\ndf.select(\"authorid\", \"name\", \"papercount\").show(3)\nOutput:\n\nApache Spark Summary Sorting Output\nMongoDB\nMongoDB is a fast and flexible database tool built for exploring and analyzing large scale datasets. Think of it as a robust digital warehouse where you can efficiently organize, store, and retrieve large volumes of data. In addition, MongoDB is a NoSQL database that stores data in a flexible schema-less format, scales horizontally, supports various data models, and is optimized for performance. MongoDB offers both on-premise and fully managed cloud options (Atlas) and can be accessed via the Mongo shell or a GUI (known as Mongo Compass). You can check out our guide on setting up Mongo if you need help getting started. In the example below, we have imported a papers dataset into a Mongo Atlas cluster and show you how to leverage the Mongo Compass GUI to view and explore your data.\n\nOnce you have imported your data, you can view it via Compass as shown in the example below. You can leverage the Compass documentation to discover all its capabilities. We have listed some key items on the user interface to get you acquainted:\n\nData can be viewed in the default list view (shown below), object view, or table view by toggling the button on the upper right hand corner. In the list view, each \u2018card\u2019 displays a single record, or in this case a paper object. Notice that MongoDB appends its own ID, known as ObjectId to each record.\nYou can filter and analyze your data using the filter pane at the top of the screen, and click on the Explain button to see how your filters were applied to obtain your result set. Note that since Mongo is a NoSQL database, it has a slightly different query language from SQL to use for filtering and manipulation.\nThe default tab is the Documents tab where you can view and scroll through your data. You can also switch to the Aggregations tab to transform, filter, group, and perform aggregate operations on your dataset. In the Schema tab, Mongo provides an analysis of the schema of your dataset. When you click on the Indexes tab, you will find that the default index for searches is Mongo\u2019s ObjectId. If you believe you will perform frequent searches using another attribute (e.g. corpusid), you can add an additional index to optimize performance.\nYou can always add more data to your dataset via the green Add Data button right under the filter query bar\nMongoDB UI\nSetting Up MongoDB\nYou have the option of installing MongoDB onto your machine, or using their managed database-as-a-service option on the cloud, otherwise known as Atlas. Once you set up your database, you can download the GUI tool (Mongo Compass) and connect it to your database to visually interact with your data. If you are new to mongo and want to just explore, you can setup a free cluster on Atlas with just a few easy steps:\n\nSet Up a Free Cluster on MongoDB Atlas:\n\nSign Up/Login:\n1.1. Visit the MongoDB Atlas website.\n1.2. Sign up for a new account or log in if you already have one.\nCreate a New Cluster:\n2.1. After logging in, click on \"Build a Cluster.\"\n2.2. Choose the free tier (M0) or another desired plan.\n2.3. Select your preferred cloud provider and region.\nConfigure Cluster:\n3.1. Set up additional configurations, such as cluster name and cluster tier.\n3.2. Click \"Create Cluster\" to initiate the cluster deployment. It may take a few minutes.\nConnect to MongoDB Compass:\n\nDownload and Install MongoDB Compass:\n1.1. Download MongoDB Compass from the official website.\n1.2. Install the Compass application on your computer.\nRetrieve Connection String:\n2.1. In MongoDB Atlas, go to the \"Clusters\" section.\n2.2. Click on \"Connect\" for your cluster.\n2.3. Choose \"Connect Your Application.\"\n2.4. Copy the connection string.\nConnect Compass to Atlas:\n3.1. Open MongoDB Compass.\n3.2. Paste the connection string in the connection dialog.\n3.3. Modify the username, password, and database name if needed.\n3.4. Click \"Connect.\"\nImport Data:\n\nCreate a Database and Collection:\n1.1. In MongoDB Compass, navigate to the \"Database\" tab.\n1.2. Create a new database and collection by clicking \"Create Database\" and \"Add My Own Data.\"\nImport Data:\n2.1. In the new collection, click \"Add Data\" and choose \"Import File.\"\n2.2. Select your JSON or CSV file containing the data.\n2.3. Map fields if necessary and click \"Import.\"\nVerify Data:\n3.1. Explore the imported data in MongoDB Compass to ensure it's displayed correctly.\nNow, you have successfully set up a free cluster on MongoDB Atlas, connected MongoDB Compass to the cluster, and imported data into your MongoDB database. This process allows you to start working with your data using MongoDB's powerful tools.\n\nTIP: We recommend checking the Mongo website for the latest installation instructions and FAQ in case you run into any issues.\n\nExample: Querying, Filtering, and Sorting. Using the Mongo Compass GUI we can filter and sort our dataset per our needs. For example, let's see which papers in Medicine were cited the most in the last 5 years, and exclude any papers with under 50 citations. In the project field we choose which fields we would like to display in the output, and we sort in descending order by citationcount \n\n{\n   's2fieldsofstudy.category': 'Medicine',\n   'citationcount': {\n       '$gte': 50\n   },\n   'year': {\n       '$gte': 2019,\n       '$lte': 2023\n   }\n}\nMongoDB\nOutput:\n\nMongoDB Output\nWorking with Multiple Datasets\nOftentimes we may want to combine information from multiple datasets to gather insights. Consider the following example:\n\nUse case: Let\u2019s delve into a publication venue, such as the \u201cJournal of the Geological Society\u201d, and learn more about the papers that have been published in it. Perhaps we would like to gather the names of authors who have published a paper in this journal, but only those whose papers have been cited at least 15 times. We can combine information from the publication venues dataset and the papers dataset to find the authors that meet this criteria. To do this, we can load our datasets into pandas dataframes and retrieve the publication venue ID associated with the \u201cJournal of the Geological Society\u201d from the publication venues dataset. Then we can search the papers dataset for papers that have a citationcount of at least 15 and are tagged to that venue ID. Finally we can collect the names of authors associated with each of those papers that met our criteria. From this point you can explore other possibilities, such as viewing other papers published by those authors, checking out their homepage on the Semantic Scholar website, and more.\n\nPython Example:\n\nimport pandas as pd\n\n# Create Pandas DataFrames\npapers_df = pd.read_json('papersDataset', lines=True)\nvenues_df = pd.read_json('publicationVenuesDataset', lines=True)\n\n# Find the venue id for our publication venue of interest - \"Journal of the Geological Society\"\npublication_venue_id = venues_df.loc[venues_df[\"name\"] == \"Journal of the Geological Society\", \"id\"].values[0]\n\n# Filter papers based on the venue id with a citation count of at least 15\nfiltered_geology_papers = papers_df.loc[\n    (papers_df[\"publicationvenueid\"] == publication_venue_id) & (papers_df[\"citationcount\"] >= 15)\n]\n\n# Traverse the list of authors for each paper that met our filter criteria and collect their names into a list\nauthor_names = []\nfor authors_list in filtered_geology_papers[\"authors\"]:\n    author_names.extend(author[\"name\"] for author in authors_list)\n\n# Print the resulting author names, with each name on a new line\nprint(\"Authors associated with papers from the Journal of the Geological Society:\")\nprint(*author_names, sep=\"\\n\")\nOutput:\n\nMultiple Datasets Output\n\nJoin the Semantic Scholar API Community Slack Channel\nGet Started\nLatest News & Updates\nCase Study: Iterative Design for Skimming Support\nCase Study: Iterative Design for Skimming Support\nOct 6, 2023\n7 min read\nHow might we help researchers quickly assess the relevance of scientific literature? Take a closer look at Skimming, Semantic Reader\u2019s latest AI feature, and the collaborative design process behind it.\n\nCassidy Trier\nBehind the Scenes of Semantic Scholar\u2019s New Author Influence Design\nBehind the Scenes of Semantic Scholar\u2019s New Author Influence Design\nAug 17, 2023\n5 min read\nWe released a new version of Author Influence interface to help scholars better discover other scholars in their fields. Here's how we identified user insights and made those design choices.\n\nCassidy Trier, Evie Cheng, Ashley Lee\nArtificial-intelligence search engines wrangle academic literature\nArtificial-intelligence search engines wrangle academic literature\nAug 7, 2023\n5 min read\nNature had a chat with Dan Weld, Chief Scientist at Semantic Scholar, to discuss how search engines are helping scientists explore and innovate by making it easier to draw connections from a massive collection of scientific literature.\n\nAmanda Heidt\nWhat Is Semantic Scholar?\nSemantic Scholar is a free, AI-powered research tool for scientific literature, based at Ai2.\n\nLearn More\nAbout\nAbout Us\nPublishers\nBlog\nAi2 Careers\nProduct\nProduct Overview\nSemantic Reader\nScholar's Hub\nBeta Program\nAPI\nAPI Overview\nAPI Tutorials\nAPI Documentation\nAPI Gallery\nResearch\nPublications\nResearch Careers\nResources\nHelp\nFAQ\nLibrarians\nTutorials\nProudly built by Ai2 with the help of our Collaborators\nTerms of Service  \u2022  Privacy Policy  \u2022  API License Agreement\n\n"
        }
      ],
      "files": [
        {
          "file_name": "paste.txt"
        }
      ]
    },
    {
      "uuid": "80bdace3-52a7-4759-972c-5e82ff551176",
      "text": " I'll help you create a simple curl command to test your Semantic Scholar API key. Based on the documentation, we can use the paper details endpoint which is a straightforward GET request.\n\nHere's the curl command:\n\n```bash\ncurl -H \"x-api-key: $SEMANTIC_SCHOLAR_API_KEY\" \\\n     \"https://api.semanticscholar.org/graph/v1/paper/649def34f8be52c8b66281af98ae884c09aef38b?fields=title,year\"\n```\n\nThis command:\n- Uses the example paper ID from the documentation\n- Requests just the title and year fields to keep it simple\n- Includes your API key in the header\n\nIf your API key is valid, you should receive a JSON response with the paper's title and year. If there's an issue with the API key, you'll receive an error response.\n\nWould you like me to explain what the expected successful response should look like?",
      "content": [
        {
          "start_timestamp": "2025-02-13T03:56:04.957367Z",
          "stop_timestamp": "2025-02-13T03:56:08.222385Z",
          "flags": null,
          "type": "text",
          "text": " I'll help you create a simple curl command to test your Semantic Scholar API key. Based on the documentation, we can use the paper details endpoint which is a straightforward GET request.\n\nHere's the curl command:\n\n```bash\ncurl -H \"x-api-key: $SEMANTIC_SCHOLAR_API_KEY\" \\\n     \"https://api.semanticscholar.org/graph/v1/paper/649def34f8be52c8b66281af98ae884c09aef38b?fields=title,year\"\n```\n\nThis command:\n- Uses the example paper ID from the documentation\n- Requests just the title and year fields to keep it simple\n- Includes your API key in the header\n\nIf your API key is valid, you should receive a JSON response with the paper's title and year. If there's an issue with the API key, you'll receive an error response.\n\nWould you like me to explain what the expected successful response should look like?",
          "citations": []
        }
      ],
      "sender": "assistant",
      "created_at": "2025-02-13T03:56:08.937344Z",
      "updated_at": "2025-02-13T03:56:08.937344Z",
      "attachments": [],
      "files": []
    }
  ]
}